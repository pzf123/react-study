
<!--
 * @Author: pzf
 * @description: 文件描述
 * @Date: 2021-09-13 18:01:21
 * @LastEditors: pzf
 * @LastEditTime: 2021-09-18 11:38:07
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
    <title>Hello react</title> 
    <!-- 引入react核心库 -->
	<script type="text/javascript" src="../js/react.development.js"></script>
	<!-- 引入react-dom，用于支撑react操作DOM-->
	<script type="text/javascript" src="../js/react-dom.development.js"></script>
	<!-- 引入babel，用于将jsx转为js -->
	<script type="text/javascript" src="../js/babel.min.js"></script>
</head>
<body>
    <div id="test"></div> 
    <script type="text/babel">  
        // 创建类式组件
        // 要继承React类的方法
        // let that = this
        class Weatcher extends React.Component {  
            /*
                构造器掉用了几次？ 1次
            **/
            constructor (props) { 
                super(props)
                // that = this
                // react官方要求state传的是对象
                // 借助构造器初始化state（状态）
                this.state = {
                    isHot: false, 
                    isHotMsg: '很热',
                    isNoHotMsh: '凉快'
                }
                // 返回一个新函数，并把this指向实例对象
                // 解决this指向问题
                this.changeWeatcher = this.changeWeatcher.bind(this)
            }
            /*
               render调用几次 1 + n 次， 1是初始化，n是状态更新的次数 
            **/
            render() { 
                // 这里的this是实例对象
                // onClick接收的是表达式，不要执行的结果
                // 这里调用的 changeWeatcher是在实例对象上的，不是在原型对象上的
                return <h1 onClick={this.changeWeatcher}>{this.state.isHot ? this.state.isHotMsg : this.state.isNoHotMsh}</h1>
            }
            changeWeatcher () {
                /*
                    changeWeather放在Weatcher的原型对象上，供实例使用
                    通过Weather实例掉用，this就是weather实例
                    函数指向它调用的对象
                    由于changeWeather作为onClick的回调不是作为实例调用，是直接调用,
                    类的方法开启了局部的严格模式，所以this指向的是undefined
                **/ 
                // 获取原来的值
                const isHot = this.state.isHot 
                /* 
                    切换了页面不刷新
                    this.state.isHot = !this.state.isHot
                    注意：状态里的数据不能直接更改,react不认可这个更改，要借助一个内置的API去更改 
                    采用setState这个api去改
                    传进去一个对象，对应指定值，是一个合并的动作     
                **/ 
                this.setState({ 
                    isHot: !isHot
                })
            }
        } 
        // 渲染组件页面
        ReactDOM.render(<Weatcher />, document.getElementById('test'))
        function demo() {
            alert('点击')
        }
        // 自定义函数，
        function demo2 () {
             //  babel翻译后是严格模式，禁止自定义的this指向window
            //  this是undefine
            alert('标题被点击了')
            // 这样写很繁琐
            // console.log(that.state.isNoHotMsh)
        }
    </script>
    
</body>
</html>